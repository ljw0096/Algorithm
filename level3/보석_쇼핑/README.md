## Programmers Level3 보석 쇼핑

- 문제 링크 : [보석 쇼핑](https://school.programmers.co.kr/learn/courses/30/lessons/67258)

- 풀이 여부 : NOT SOLVE (second solve)
- 풀이 시간 : 40분

### 초기 설계

- 1차원 배열에서 연속된 구간 중 특정 조건을 만족하는 구간을 탐색하는 문제이고, 시간 효율성 체크까지 존재했기 때문에 이론상 O(n) 시간에 문제를 해결할 수 있는 투포인터 방식으로 접근
- 시작 포인터는 현재 구간에 모든 보석이 모였을 때 증가
- 끝 포인터는 현재 구간에 모든 보석이 모이지 않았을 때 증가
- 반복문은 끝 포인터가 마지막 Index가 되었을 때 중단
- 각 구간의 보석 수집 여부는 Map객체의 values를 검사하면서 모든 값이 0 이상인지 판단

### 문제점

- first 코드에서 정확성과 일부 효율성 케이스를 해결하였으나, 일부에서는 시간 초과가 발생
- 보석 수집 여부를 판단하는 `hasAllGems()` 함수가 gems 갯수만큼 반복하기 때문에 효율적이지 않음
  - spread 연산자 사용
  - every 연산을 사용했기 때문에 O(n \* m(보석 종류)) => 약 O(n^2)만큼의 시간이 소요될 것으로 판단

### 개선

- 현재 구간의 보석이 모두 모였는가 아닌가를 판단할 때 Map의 size를 이용하도록 변경
  - 현재 Map에 key 값이 없다면 1로 설정, 있다면 1씩 증가
  - Map에서 보석을 제거시 key 값이 1이라면 Map에서 delete, 아니라면 1 감소
  - 해당 방식으로 Map.size와 targetSize를 비교해서 비교연산 시간을 O(1)으로 단축
